from numpy import array, savetxt, vstack, hstack, round
from matplotlib.pyplot import figure, show
from mpl_toolkits.mplot3d import axes3d
from datetime import datetime
from os import mkdir

from magforce import normalize, getF


# functions for plotting 1D

def plot_1D_along_x(xs=array([]), y=0, z=0, collections={}, sample={}, BF='BF', saveCSV=False, showim=False):
    """
    -----------
    DESCRIPTION
    -----------

    Plots Bx, By, Bz and Fx, Fy, Fz generated by a collection of magnets into a ferromagnetic sample.
    Those variables are plotted along the x direction

    ----------
    PARAMETERS
    ----------

    :param xs: numpy.array | contains the x direction values where the variables are evaluated [mm]
    :param y: float | float for y direction [mm]
    :param z: float | float for z direction [mm]
    :param collections: dict | the magnets setup to be studied arranged like {'name':magpylib.Collection}
    :param sample: dict | keys 'demagnetizing_factor' [], 'volume' [m3] and 'M_saturation' [A/m]
    :param BF: str | 'B' to plot Bx, By, Bz; 'F' to plot Fx, Fy, Fz; 'BF' for both
    :param saveCSV: bool | True for saving a CSV file with the data generated by the function
    :param showim: bool | True to show images after calculation, False to call yourself show() afterwards in the code
    :return: plots matplotlib graphs. show() needs to be called manually

    -------
    EXAMPLE
    -------

    # imports
        >>> from numpy import linspace, pi
        >>> from matplotlib.pyplot import show
        >>> from magpylib import Collection, displaySystem
        >>> from magpylib.source.magnet import Cylinder
        >>> from magforce import plot_1D_along_x

    # sample Definition
        >>> demagnetizing_factor = 1/3             # sphere
        >>> volume = 4 / 3 * pi * (4 / 1000) ** 3  # V sphere r=4mm [m3]
        >>> M_saturation = 1.400e6                 # Ms Co room temperature [A/m]
        >>> sample = {'demagnetizing_factor': demagnetizing_factor, 'volume': volume, 'M_saturation': M_saturation}

    # magnet collection definition
        >>> m1 = Cylinder(mag=[0, 0, 1300],
        ...               dim=[10, 20],
        ...               pos=[0, 0, -20])  # center is at z = -20mm

        >>> m2 = Cylinder(mag=[0, 0, 1300],
        ...               dim=[10, 20],
        ...               pos=[0, 0, 20]) # center is at z = 20mm

        >>> both = Collection(m1, m2)

    # magnet collection visualisation
        >>> displaySystem(both, suppress=True)
        <Figure size 640x640 with 1 Axes>

    # study of different arrangements along z axis
        >>> plot_1D_along_x(xs = linspace(-5, 5, 1000),
        ...                 y = 4,
        ...                 z = 2,
        ...                 collections = {'z-20': m1,
        ...                                'z+20': m2,
        ...                                'both': both},
        ...                 sample = sample,
        ...                 BF = 'BF',
        ...                 saveCSV = False,
        ...                 showim=True)
    """

    # generate points for B and F calculation
    POS = array([(x, y, z) for x in xs])

    # pass BF to uppercase to avoid BF='bf' not returning anything
    BF = BF.upper()

    # dictionary to store all the calculated values that will generate the CSV file afterwards
    if saveCSV:
        CSVs = {key:[] for key in collections.keys()}

    # if user wants plotting of B
    if 'B' in BF:
        # create figure to host 4 plots in 2x2 disposition
        fig_B = figure(num=f'''B for y = {y}, z = {z} -- ''' +
                           '; '.join(f'{name}' for name in collections.keys()),
                       constrained_layout=True)
        outer_grid = fig_B.add_gridspec(2, 2, wspace=0, hspace=0)

        ax_Bx = fig_B.add_subplot(outer_grid[0], title=f'''Bx along x axis, y = {y}, z = {z}''')
        ax_By = fig_B.add_subplot(outer_grid[1], title=f'''By along x axis, y = {y}, z = {z}''')
        ax_Bz = fig_B.add_subplot(outer_grid[2], title=f'''Bz along x axis, y = {y}, z = {z}''')

        B_all = outer_grid[3].subgridspec(1, len(collections), wspace=0, hspace=0)

        styles = ['-', '--', ':', '-.']

        # iterates B for each collection in collections
        for i, pair in enumerate(collections.items()):
            name, collection = pair

            # calculate B in mT
            B_field = array([collection.getB(pos) for pos in POS])

            # split B into lists of Bx, By, Bz
            Bx = B_field[:, 0]
            By = B_field[:, 1]
            Bz = B_field[:, 2]

            # plot Bx along x
            ax_Bx.plot(xs, Bx, f'r{styles[i % 4]}', label=f'Bx; {name}')
            ax_Bx.set_xlabel('x [mm]')
            ax_Bx.set_ylabel('Bx [mT]')
            ax_Bx.legend()

            # plot By along x
            ax_By.plot(xs, By, f'g{styles[i % 4]}', label=f'By; {name}')
            ax_By.set_xlabel('x [mm]')
            ax_By.set_ylabel('By [mT]')
            ax_By.legend()

            # plot Fz along x
            ax_Bz.plot(xs, Bz, f'b{styles[i % 4]}', label=f'Bz; {name}')
            ax_Bz.set_xlabel('x [mm]')
            ax_Bz.set_ylabel('Bz [mT]')
            ax_Bz.legend()

            # joins Bx, By and Bz along x in one plot
            if i == 0:
                ax_B_all_0 = fig_B.add_subplot(B_all[i], title=name)
                ax_B_all_0.plot(xs, Bx, f'r{styles[i % 4]}', label=f'Bx')
                ax_B_all_0.plot(xs, By, f'g{styles[i % 4]}', label=f'By')
                ax_B_all_0.plot(xs, Bz, f'b{styles[i % 4]}', label=f'Bz')
                ax_B_all_0.set_xlabel('x [mm]')
                ax_B_all_0.set_ylabel('B [mT]')
                ax_B_all_0.legend()
            else:
                ax_B_all_n = fig_B.add_subplot(B_all[i], title=name, sharey=ax_B_all_0)
                ax_B_all_n.plot(xs, Bx, f'r{styles[i % 4]}', label=f'Bx')
                ax_B_all_n.plot(xs, By, f'g{styles[i % 4]}', label=f'By')
                ax_B_all_n.plot(xs, Bz, f'b{styles[i % 4]}', label=f'Bz')
                ax_B_all_n.get_yaxis().set_visible(False)
                ax_B_all_n.set_xlabel('x [mm]')
                ax_B_all_n.legend()

            # adding data to CSV
            if saveCSV:
                B_titles = array([[f'Bx {name}', f'By {name}', f'Bz {name}'],
                                  ['[mT]', '[mT]', '[mT]']])
                B_titled = vstack((B_titles, B_field))
                CSVs[name].append(B_titled)

    # if user wants plotting of F
    if 'F' in BF:
        # create figure to host 4 plots in 2x2 disposition
        fig_F = figure(num=f'''F for y = {y}, z = {z} -- ''' +
                           '; '.join(f'{name}' for name in collections.keys()),
                       constrained_layout=True)
        outer_grid = fig_F.add_gridspec(2, 2, wspace=0, hspace=0)

        ax_Fx = fig_F.add_subplot(outer_grid[0], title=f'''Fx along x axis, y = {y}, z = {z}''')
        ax_Fy = fig_F.add_subplot(outer_grid[1], title=f'''Fy along x axis, y = {y}, z = {z}''')
        ax_Fz = fig_F.add_subplot(outer_grid[2], title=f'''Fz along x axis, y = {y}, z = {z}''')

        F_all = outer_grid[3].subgridspec(1, len(collections), wspace=0, hspace=0)

        styles = ['-', '--', ':', '-.']

        # iterates F for each collection in collections
        for i, pair in enumerate(collections.items()):
            name, collection = pair
            # calculate F in N
            F_field = array([getF(pos, collection, sample) for pos in POS])

            # split F into lists of Fx, Fy, Fz
            Fx = F_field[:, 0]
            Fy = F_field[:, 1]
            Fz = F_field[:, 2]

            # plot Fx along x
            ax_Fx.plot(xs, Fx, f'r{styles[i%4]}', label=f'Fx; {name}')
            ax_Fx.set_xlabel('x [mm]')
            ax_Fx.set_ylabel('Fx [N]')
            ax_Fx.legend()

            # plot Fy along x
            ax_Fy.plot(xs, Fy, f'g{styles[i%4]}', label=f'Fy; {name}')
            ax_Fy.set_xlabel('x [mm]')
            ax_Fy.set_ylabel('Fy [N]')
            ax_Fy.legend()

            # plot Fz along x
            ax_Fz.plot(xs, Fz, f'b{styles[i%4]}', label=f'Fz; {name}')
            ax_Fz.set_xlabel('x [mm]')
            ax_Fz.set_ylabel('Fz [N]')
            ax_Fz.legend()

            # joins Fx, Fy and Fz along x in one plot
            if i == 0:
                ax_F_all_0 = fig_F.add_subplot(F_all[i], title=name)
                ax_F_all_0.plot(xs, Fx, f'r{styles[i%4]}', label=f'Fx')
                ax_F_all_0.plot(xs, Fy, f'g{styles[i%4]}', label=f'Fy')
                ax_F_all_0.plot(xs, Fz, f'b{styles[i%4]}', label=f'Fz')
                ax_F_all_0.set_xlabel('x [mm]')
                ax_F_all_0.set_ylabel('Force [N]')
                ax_F_all_0.legend()
            else:
                ax_F_all_n = fig_F.add_subplot(F_all[i], title=name, sharey=ax_F_all_0)
                ax_F_all_n.plot(xs, Fx, f'r{styles[i%4]}', label=f'Fx')
                ax_F_all_n.plot(xs, Fy, f'g{styles[i%4]}', label=f'Fy')
                ax_F_all_n.plot(xs, Fz, f'b{styles[i%4]}', label=f'Fz')
                ax_F_all_n.get_yaxis().set_visible(False)
                ax_F_all_n.set_xlabel('x [mm]')
                ax_F_all_n.legend()

            # adding data to CSV
            if saveCSV:
                F_titles = array([[f'Fx {name}', f'Fy {name}', f'Fz {name}'],
                                  ['[N]', '[N]', '[N]']])
                F_titled = vstack((F_titles, F_field))
                CSVs[name].append(F_titled)

    if saveCSV:
        dirname = "CSV_output"
        try:
            # Create target Directory
            mkdir(dirname)
            print(f"Directory {dirname} created, saving CSV file there")
        except FileExistsError:
            print(f"Directory {dirname} already exists, saving CSV file there")

        # prepare CSV data with POS
        POS_titles = array([['x', 'y', 'z'],
                            ['[mm]', '[mm]', '[mm]']])
        POS_titled = vstack((POS_titles, POS))
        CSV_data = [POS_titled]

        # append other data
        for arr in list(CSVs.values()):
            CSV_data.append(hstack(arr))

        # save it
        header = f'Simulation 1D along x | {datetime.now()}'
        savetxt(f'CSV_output/{BF}_1D_along_x.csv', hstack(CSV_data), delimiter=';', fmt='%s', header=header)

    if showim:
        show()


def plot_1D_along_y(x=0, ys=array([]), z=0, collections={}, sample={}, BF='BF', saveCSV=False, showim=False):
    """
    -----------
    DESCRIPTION
    -----------

    Plots Bx, By, Bz and Fx, Fy, Fz generated by a collection of magnets into a ferromagnetic sample.
    Those variables are plotted along the x direction

    ----------
    PARAMETERS
    ----------

    :param x: float | float for x direction [mm]
    :param ys: numpy.array | contains the y direction values where the variables are evaluated [mm]
    :param z: float | float for z direction [mm]
    :param collections: dict | the magnets setup to be studied arranged like {'name':magpylib.Collection}
    :param sample: dict | keys 'demagnetizing_factor' [], 'volume' [m3] and 'M_saturation' [A/m]
    :param BF: str | 'B' to plot Bx, By, Bz; 'F' to plot Fx, Fy, Fz; 'BF' for both
    :param saveCSV: bool | True for saving a CSV file with the data generated by the function
    :param showim: bool | True to show images after calculation, False to call yourself show() afterwards in the code
    :return: plots matplotlib graphs. show() needs to be called manually

    -------
    EXAMPLE
    -------

    # imports
        >>> from numpy import linspace, pi
        >>> from matplotlib.pyplot import show
        >>> from magpylib import Collection, displaySystem
        >>> from magpylib.source.magnet import Cylinder
        >>> from magforce import plot_1D_along_y

    # sample Definition
        >>> demagnetizing_factor = 1/3             # sphere
        >>> volume = 4 / 3 * pi * (4 / 1000) ** 3  # V sphere r=4mm [m3]
        >>> M_saturation = 1.400e6                 # Ms Co room temperature [A/m]
        >>> sample = {'demagnetizing_factor': demagnetizing_factor, 'volume': volume, 'M_saturation': M_saturation}

    # magnet collection definition
        >>> m1 = Cylinder(mag=[0, 0, 1300],
        ...               dim=[10, 20],
        ...               pos=[0, 0, -20])  # center is at z = -20mm

        >>> m2 = Cylinder(mag=[0, 0, 1300],
        ...               dim=[10, 20],
        ...               pos=[0, 0, 20]) # center is at z = 20mm

        >>> both = Collection(m1, m2)

    # magnet collection visualisation
        >>> displaySystem(both, suppress=True)
        <Figure size 640x640 with 1 Axes>

    # study of different arrangements along z axis
        >>> plot_1D_along_y(x = 4,
        ...                 ys = linspace(-5, 5, 1000),
        ...                 z = 2,
        ...                 collections = {'z-20': m1,
        ...                                'z+20': m2,
        ...                                'both': both},
        ...                 sample = sample,
        ...                 BF = 'BF',
        ...                 saveCSV = False,
        ...                 showim=True)
    """

    # generate points for B and F calculation
    POS = array([(x, y, z) for y in ys])

    # pass BF to uppercase to avoid BF='bf' not returning anything
    BF = BF.upper()

    # dictionary to store all the calculated values that will generate the CSV file afterwards
    if saveCSV:
        CSVs = {key:[] for key in collections.keys()}

    # if user wants plotting of B
    if 'B' in BF:
        # create figure to host 4 plots in 2x2 disposition
        fig_B = figure(num=f'''B for x = {x}, z = {z} -- ''' +
                           '; '.join(f'{name}' for name in collections.keys()),
                       constrained_layout=True)
        outer_grid = fig_B.add_gridspec(2, 2, wspace=0, hspace=0)

        ax_Bx = fig_B.add_subplot(outer_grid[0], title=f'''Bx along y axis, x = {x}, z = {z}''')
        ax_By = fig_B.add_subplot(outer_grid[1], title=f'''By along y axis, x = {x}, z = {z}''')
        ax_Bz = fig_B.add_subplot(outer_grid[2], title=f'''Bz along y axis, x = {x}, z = {z}''')

        B_all = outer_grid[3].subgridspec(1, len(collections), wspace=0, hspace=0)

        styles = ['-', '--', ':', '-.']

        # iterates B for each collection in collections
        for i, pair in enumerate(collections.items()):
            name, collection = pair

            # calculate B in mT
            B_field = array([collection.getB(pos) for pos in POS])

            # split B into lists of Bx, By, Bz
            Bx = B_field[:, 0]
            By = B_field[:, 1]
            Bz = B_field[:, 2]

            # plot Bx along y
            ax_Bx.plot(ys, Bx, f'r{styles[i % 4]}', label=f'Bx; {name}')
            ax_Bx.set_xlabel('y [mm]')
            ax_Bx.set_ylabel('Bx [mT]')
            ax_Bx.legend()

            # plot By along y
            ax_By.plot(ys, By, f'g{styles[i % 4]}', label=f'By; {name}')
            ax_By.set_xlabel('y [mm]')
            ax_By.set_ylabel('By [mT]')
            ax_By.legend()

            # plot Fz along y
            ax_Bz.plot(ys, Bz, f'b{styles[i % 4]}', label=f'Bz; {name}')
            ax_Bz.set_xlabel('y [mm]')
            ax_Bz.set_ylabel('Bz [mT]')
            ax_Bz.legend()

            # joins Bx, By and Bz along y in one plot
            if i == 0:
                ax_B_all_0 = fig_B.add_subplot(B_all[i], title=name)
                ax_B_all_0.plot(ys, Bx, f'r{styles[i % 4]}', label=f'Bx')
                ax_B_all_0.plot(ys, By, f'g{styles[i % 4]}', label=f'By')
                ax_B_all_0.plot(ys, Bz, f'b{styles[i % 4]}', label=f'Bz')
                ax_B_all_0.set_xlabel('y [mm]')
                ax_B_all_0.set_ylabel('B [mT]')
                ax_B_all_0.legend()
            else:
                ax_B_all_n = fig_B.add_subplot(B_all[i], title=name, sharey=ax_B_all_0)
                ax_B_all_n.plot(ys, Bx, f'r{styles[i % 4]}', label=f'Bx')
                ax_B_all_n.plot(ys, By, f'g{styles[i % 4]}', label=f'By')
                ax_B_all_n.plot(ys, Bz, f'b{styles[i % 4]}', label=f'Bz')
                ax_B_all_n.get_yaxis().set_visible(False)
                ax_B_all_n.set_xlabel('y [mm]')
                ax_B_all_n.legend()

            # adding data to CSV
            if saveCSV:
                B_titles = array([[f'Bx {name}', f'By {name}', f'Bz {name}'],
                                  ['[mT]', '[mT]', '[mT]']])
                B_titled = vstack((B_titles, B_field))
                CSVs[name].append(B_titled)

    # if user wants plotting of F
    if 'F' in BF:
        # create figure to host 4 plots in 2x2 disposition
        fig_F = figure(num=f'''F for x = {x}, z = {z} -- ''' +
                           '; '.join(f'{name}' for name in collections.keys()),
                       constrained_layout=True)
        outer_grid = fig_F.add_gridspec(2, 2, wspace=0, hspace=0)

        ax_Fx = fig_F.add_subplot(outer_grid[0], title=f'''Fx along y axis, x = {x}, z = {z}''')
        ax_Fy = fig_F.add_subplot(outer_grid[1], title=f'''Fy along y axis, x = {x}, z = {z}''')
        ax_Fz = fig_F.add_subplot(outer_grid[2], title=f'''Fz along y axis, x = {x}, z = {z}''')

        F_all = outer_grid[3].subgridspec(1, len(collections), wspace=0, hspace=0)

        styles = ['-', '--', ':', '-.']

        # iterates F for each collection in collections
        for i, pair in enumerate(collections.items()):
            name, collection = pair
            # calculate F in N
            F_field = array([getF(pos, collection, sample) for pos in POS])

            # split F into lists of Fx, Fy, Fz
            Fx = F_field[:, 0]
            Fy = F_field[:, 1]
            Fz = F_field[:, 2]

            # plot Fx along y
            ax_Fx.plot(ys, Fx, f'r{styles[i%4]}', label=f'Fx; {name}')
            ax_Fx.set_xlabel('y [mm]')
            ax_Fx.set_ylabel('Fx [N]')
            ax_Fx.legend()

            # plot Fy along y
            ax_Fy.plot(ys, Fy, f'g{styles[i%4]}', label=f'Fy; {name}')
            ax_Fy.set_xlabel('y [mm]')
            ax_Fy.set_ylabel('Fy [N]')
            ax_Fy.legend()

            # plot Fz along y
            ax_Fz.plot(ys, Fz, f'b{styles[i%4]}', label=f'Fz; {name}')
            ax_Fz.set_xlabel('y [mm]')
            ax_Fz.set_ylabel('Fz [N]')
            ax_Fz.legend()

            # joins Fx, Fy and Fz along x in one plot
            if i == 0:
                ax_F_all_0 = fig_F.add_subplot(F_all[i], title=name)
                ax_F_all_0.plot(ys, Fx, f'r{styles[i%4]}', label=f'Fx')
                ax_F_all_0.plot(ys, Fy, f'g{styles[i%4]}', label=f'Fy')
                ax_F_all_0.plot(ys, Fz, f'b{styles[i%4]}', label=f'Fz')
                ax_F_all_0.set_xlabel('y [mm]')
                ax_F_all_0.set_ylabel('Force [N]')
                ax_F_all_0.legend()
            else:
                ax_F_all_n = fig_F.add_subplot(F_all[i], title=name, sharey=ax_F_all_0)
                ax_F_all_n.plot(ys, Fx, f'r{styles[i%4]}', label=f'Fx')
                ax_F_all_n.plot(ys, Fy, f'g{styles[i%4]}', label=f'Fy')
                ax_F_all_n.plot(ys, Fz, f'b{styles[i%4]}', label=f'Fz')
                ax_F_all_n.get_yaxis().set_visible(False)
                ax_F_all_n.set_xlabel('y [mm]')
                ax_F_all_n.legend()

            # adding data to CSV
            if saveCSV:
                F_titles = array([[f'Fx {name}', f'Fy {name}', f'Fz {name}'],
                                  ['[N]', '[N]', '[N]']])
                F_titled = vstack((F_titles, F_field))
                CSVs[name].append(F_titled)

    if saveCSV:
        dirname = "CSV_output"
        try:
            # Create target Directory
            mkdir(dirname)
            print(f"Directory {dirname} created, saving CSV file there")
        except FileExistsError:
            print(f"Directory {dirname} already exists, saving CSV file there")

        # prepare CSV data with POS
        POS_titles = array([['x', 'y', 'z'],
                            ['[mm]', '[mm]', '[mm]']])
        POS_titled = vstack((POS_titles, POS))
        CSV_data = [POS_titled]

        # append other data
        for arr in list(CSVs.values()):
            CSV_data.append(hstack(arr))

        # save it
        header = f'Simulation 1D along y | {datetime.now()}'
        savetxt(f'CSV_output/{BF}_1D_along_y.csv', hstack(CSV_data), delimiter=';', fmt='%s', header=header)

    if showim:
        show()


def plot_1D_along_z(x=0, y=0, zs=array([]), collections={}, sample={}, BF='BF', saveCSV=False, showim=False):
    """
    -----------
    DESCRIPTION
    -----------

    Plots Bx, By, Bz and Fx, Fy, Fz generated by a collection of magnets into a ferromagnetic sample.
    Those variables are plotted along the z direction

    ----------
    PARAMETERS
    ----------

    :param x: float | float for x direction [mm]
    :param y: float | float for y direction [mm]
    :param zs: numpy.array | contains the z direction values where the variables are evaluated [mm]
    :param collections: dict | the magnets setup to be studied arranged like {'name':magpylib.Collection}
    :param sample: dict | keys 'demagnetizing_factor' [], 'volume' [m3] and 'M_saturation' [A/m]
    :param BF: str | 'B' to plot Bx, By, Bz; 'F' to plot Fx, Fy, Fz; 'BF' for both
    :param saveCSV: bool | True for saving a CSV file with the data generated by the function
    :param showim: bool | True to show images after calculation, False to call yourself show() afterwards in the code
    :return: plots matplotlib graphs. show() needs to be called manually

    -------
    EXAMPLE
    -------

    # imports
        >>> from numpy import linspace, pi
        >>> from matplotlib.pyplot import show
        >>> from magpylib import Collection, displaySystem
        >>> from magpylib.source.magnet import Cylinder
        >>> from magforce import plot_1D_along_z

    # sample Definition
        >>> demagnetizing_factor = 1/3             # sphere
        >>> volume = 4 / 3 * pi * (4 / 1000) ** 3  # V sphere r=4mm [m3]
        >>> M_saturation = 1.400e6                 # Ms Co room temperature [A/m]
        >>> sample = {'demagnetizing_factor': demagnetizing_factor, 'volume': volume, 'M_saturation': M_saturation}

    # magnet collection definition
        >>> m1 = Cylinder(mag=[0, 0, 1300],
        ...               dim=[10, 20],
        ...               pos=[0, 0, -20])  # center is at z = -20mm

        >>> m2 = Cylinder(mag=[0, 0, 1300],
        ...               dim=[10, 20],
        ...               pos=[0, 0, 20]) # center is at z = 20mm

        >>> both = Collection(m1, m2)

    # magnet collection visualisation
        >>> displaySystem(both, suppress=True)
        <Figure size 640x640 with 1 Axes>

    # study of different arrangements along z axis
        >>> plot_1D_along_z(x = 2,
        ...                 y = 4,
        ...                 zs = linspace(-15, 15, 1000),
        ...                 collections = {'z-20': m1,
        ...                                'z+20': m2,
        ...                                'both': both},
        ...                 sample = sample,
        ...                 BF = 'BF',
        ...                 saveCSV = False,
        ...                 showim=True)
    """

    # generate points for B and F calculation
    POS = array([(x, y, z) for z in zs])

    # pass BF to uppercase to avoid BF='bf' not returning anything
    BF = BF.upper()

    # dictionary to store all the calculated values that will generate the CSV file afterwards
    if saveCSV:
        CSVs = {key:[] for key in collections.keys()}

    # if user wants plotting of B
    if 'B' in BF:
        # create figure to host 4 plots in 2x2 disposition
        fig_B = figure(num=f'''B for x = {x}, y = {y} -- ''' +
                           '; '.join(f'{name}' for name in collections.keys()),
                       constrained_layout=True)
        outer_grid = fig_B.add_gridspec(2, 2, wspace=0, hspace=0)

        ax_Bx = fig_B.add_subplot(outer_grid[0], title=f'''Bx along z axis, x = {x}, y = {y}''')
        ax_By = fig_B.add_subplot(outer_grid[1], title=f'''By along z axis, x = {x}, y = {y}''')
        ax_Bz = fig_B.add_subplot(outer_grid[2], title=f'''Bz along z axis, x = {x}, y = {y}''')

        B_all = outer_grid[3].subgridspec(1, len(collections), wspace=0, hspace=0)

        styles = ['-', '--', ':', '-.']

        # iterates B for each collection in collections
        for i, pair in enumerate(collections.items()):
            name, collection = pair

            # calculate B in mT
            B_field = array([collection.getB(pos) for pos in POS])

            # split B into lists of Bx, By, Bz
            Bx = B_field[:, 0]
            By = B_field[:, 1]
            Bz = B_field[:, 2]

            # plot Bx along z
            ax_Bx.plot(zs, Bx, f'r{styles[i % 4]}', label=f'Bx; {name}')
            ax_Bx.set_xlabel('z [mm]')
            ax_Bx.set_ylabel('Bx [mT]')
            ax_Bx.legend()

            # plot By along z
            ax_By.plot(zs, By, f'g{styles[i % 4]}', label=f'By; {name}')
            ax_By.set_xlabel('z [mm]')
            ax_By.set_ylabel('By [mT]')
            ax_By.legend()

            # plot Fz along z
            ax_Bz.plot(zs, Bz, f'b{styles[i % 4]}', label=f'Bz; {name}')
            ax_Bz.set_xlabel('z [mm]')
            ax_Bz.set_ylabel('Bz [mT]')
            ax_Bz.legend()

            # joins Bx, By and Bz along z in one plot
            if i == 0:
                ax_B_all_0 = fig_B.add_subplot(B_all[i], title=name)
                ax_B_all_0.plot(zs, Bx, f'r{styles[i % 4]}', label=f'Bx')
                ax_B_all_0.plot(zs, By, f'g{styles[i % 4]}', label=f'By')
                ax_B_all_0.plot(zs, Bz, f'b{styles[i % 4]}', label=f'Bz')
                ax_B_all_0.set_xlabel('z [mm]')
                ax_B_all_0.set_ylabel('B [mT]')
                ax_B_all_0.legend()
            else:
                ax_B_all_n = fig_B.add_subplot(B_all[i], title=name, sharey=ax_B_all_0)
                ax_B_all_n.plot(zs, Bx, f'r{styles[i % 4]}', label=f'Bx')
                ax_B_all_n.plot(zs, By, f'g{styles[i % 4]}', label=f'By')
                ax_B_all_n.plot(zs, Bz, f'b{styles[i % 4]}', label=f'Bz')
                ax_B_all_n.get_yaxis().set_visible(False)
                ax_B_all_n.set_xlabel('z [mm]')
                ax_B_all_n.legend()

            # adding data to CSV
            if saveCSV:
                B_titles = array([[f'Bx {name}', f'By {name}', f'Bz {name}'],
                                  ['[mT]', '[mT]', '[mT]']])
                B_titled = vstack((B_titles, B_field))
                CSVs[name].append(B_titled)

    # if user wants plotting of F
    if 'F' in BF:
        # create figure to host 4 plots in 2x2 disposition
        fig_F = figure(num=f'''F for x = {x}, y = {y} -- ''' +
                           '; '.join(f'{name}' for name in collections.keys()),
                       constrained_layout=True)
        outer_grid = fig_F.add_gridspec(2, 2, wspace=0, hspace=0)

        ax_Fx = fig_F.add_subplot(outer_grid[0], title=f'''Fx along z axis, x = {x}, y = {y}''')
        ax_Fy = fig_F.add_subplot(outer_grid[1], title=f'''Fy along z axis, x = {x}, y = {y}''')
        ax_Fz = fig_F.add_subplot(outer_grid[2], title=f'''Fz along z axis, x = {x}, y = {y}''')

        F_all = outer_grid[3].subgridspec(1, len(collections), wspace=0, hspace=0)

        styles = ['-', '--', ':', '-.']

        # iterates F for each collection in collections
        for i, pair in enumerate(collections.items()):
            name, collection = pair
            # calculate F in N
            F_field = array([getF(pos, collection, sample) for pos in POS])

            # split F into lists of Fx, Fy, Fz
            Fx = F_field[:, 0]
            Fy = F_field[:, 1]
            Fz = F_field[:, 2]

            # plot Fx along z
            ax_Fx.plot(zs, Fx, f'r{styles[i%4]}', label=f'Fx; {name}')
            ax_Fx.set_xlabel('z [mm]')
            ax_Fx.set_ylabel('Fx [N]')
            ax_Fx.legend()

            # plot Fy along z
            ax_Fy.plot(zs, Fy, f'g{styles[i%4]}', label=f'Fy; {name}')
            ax_Fy.set_xlabel('z [mm]')
            ax_Fy.set_ylabel('Fy [N]')
            ax_Fy.legend()

            # plot Fz along z
            ax_Fz.plot(zs, Fz, f'b{styles[i%4]}', label=f'Fz; {name}')
            ax_Fz.set_xlabel('z [mm]')
            ax_Fz.set_ylabel('Fz [N]')
            ax_Fz.legend()

            # joins Fx, Fy and Fz along z in one plot
            if i == 0:
                ax_F_all_0 = fig_F.add_subplot(F_all[i], title=name)
                ax_F_all_0.plot(zs, Fx, f'r{styles[i%4]}', label=f'Fx')
                ax_F_all_0.plot(zs, Fy, f'g{styles[i%4]}', label=f'Fy')
                ax_F_all_0.plot(zs, Fz, f'b{styles[i%4]}', label=f'Fz')
                ax_F_all_0.set_xlabel('z [mm]')
                ax_F_all_0.set_ylabel('Force [N]')
                ax_F_all_0.legend()
            else:
                ax_F_all_n = fig_F.add_subplot(F_all[i], title=name, sharey=ax_F_all_0)
                ax_F_all_n.plot(zs, Fx, f'r{styles[i%4]}', label=f'Fx')
                ax_F_all_n.plot(zs, Fy, f'g{styles[i%4]}', label=f'Fy')
                ax_F_all_n.plot(zs, Fz, f'b{styles[i%4]}', label=f'Fz')
                ax_F_all_n.get_yaxis().set_visible(False)
                ax_F_all_n.set_xlabel('z [mm]')
                ax_F_all_n.legend()

            # adding data to CSV
            if saveCSV:
                F_titles = array([[f'Fx {name}', f'Fy {name}', f'Fz {name}'],
                                  ['[N]', '[N]', '[N]']])
                F_titled = vstack((F_titles, F_field))
                CSVs[name].append(F_titled)

    if saveCSV:
        dirname = "CSV_output"
        try:
            # Create target Directory
            mkdir(dirname)
            print(f"Directory {dirname} created, saving CSV file there")
        except FileExistsError:
            print(f"Directory {dirname} already exists, saving CSV file there")

        # prepare CSV data with POS
        POS_titles = array([['x', 'y', 'z'],
                            ['[mm]', '[mm]', '[mm]']])
        POS_titled = vstack((POS_titles, POS))
        CSV_data = [POS_titled]

        # append other data
        for arr in list(CSVs.values()):
            CSV_data.append(hstack(arr))

        # save it
        header = f'Simulation 1D along z | {datetime.now()}'
        savetxt(f'CSV_output/{BF}_1D_along_z.csv', hstack(CSV_data), delimiter=';', fmt='%s', header=header)

    if showim:
        show()


# functions for plotting 2D

def plot_2D_plane_x(x=0, ys=array([]), zs=array([]), collections={}, sample={}, modes=['stream'], BF='BF', rounding=10, saveCSV=False, showim=False):
    """
    -----------
    DESCRIPTION
    -----------

    Plots B and F generated by a collection of magnets into a ferromagnetic sample.
    Those variables are plotted on a given x plane

    ----------
    PARAMETERS
    ----------

    :param x: float | float for x plane [mm]
    :param ys: numpy.array | contains the y interval values where the variables are evaluated [mm]
    :param zs: numpy.array | contains the z interval values where the variables are evaluated [mm]
    :param collections: dict | the magnets setup to be studied arranged like {'name':magpylib.Collection}
    :param sample: dict | keys 'demagnetizing_factor' [], 'volume' [m3] and 'M_saturation' [A/m]
    :param modes: list | may contain 'stream', 'quiver' or 'surface' according to plotting fashion
    :param BF: str | 'B' to plot Bx, By, Bz; 'F' to plot Fx, Fy, Fz; 'BF' for all
    :param rounding: int | decimal places to be left after rounding of final values. 'None' for no rouding.
    :param saveCSV: bool | True for saving a CSV file with the data generated by the function
    :param showim: bool | True to show images after calculation, False to call yourself show() afterwards in the code
    :return: plots matplotlib graphs. show() needs to be called manually

    -------
    EXAMPLE
    -------

    # imports
        >>> from numpy import linspace, pi
        >>> from matplotlib.pyplot import show
        >>> from magpylib import Collection, displaySystem
        >>> from magpylib.source.magnet import Cylinder
        >>> from magforce import plot_2D_plane_x

    # sample Definition
        >>> demagnetizing_factor = 1/3             # sphere
        >>> volume = 4 / 3 * pi * (4 / 1000) ** 3  # V sphere r=4mm [m3]
        >>> M_saturation = 1.400e6                 # Ms Co room temperature [A/m]
        >>> sample = {'demagnetizing_factor': demagnetizing_factor, 'volume': volume, 'M_saturation': M_saturation}

    # magnet collection definition
        >>> m1 = Cylinder(mag=[0, 0, 1300],
        ...               dim=[10, 20],
        ...               pos=[0, 0, -20])  # center is at z = -20mm

        >>> m2 = Cylinder(mag=[0, 0, 1300],
        ...               dim=[10, 20],
        ...               pos=[0, 0, 20]) # center is at z = 20mm

        >>> both = Collection(m1, m2)

    # magnet collection visualisation
        >>> displaySystem(both, suppress=True)
        <Figure size 640x640 with 1 Axes>

    # study of different arrangements along z axis
        >>> plot_2D_plane_x(x=0,
        ...                 ys=linspace(-10, 10, 35),
        ...                 zs=linspace(-20, 20, 35),
        ...                 collections={'z-20': m1,
        ...                              'both': both},
        ...                 sample=sample,
        ...                 modes=['stream', 'quiver', 'surface'],
        ...                 BF='BF',
        ...                 saveCSV=False,
        ...                 showim=True)
    """

    # get array length to reshape B or F array correctly
    lenys = len(ys)
    lenzs = len(zs)

    # generate points for B and F calculation, no reshape done yet, raw array
    POS_raw = array([(x, y, z) for z in zs for y in ys])

    # reshaping and splitting needed for matplotlib.pyplot.streamplot and plot_surface
    POS = POS_raw.reshape(lenys, lenzs, 3)
    POSy = POS[:, :, 1]
    POSz = POS[:, :, 2]

    # pass BF to uppercase to avoid BF='bf' not returning anything
    BF = BF.upper()

    # dictionary to store all the calculated values that will generate the CSV file afterwards
    if saveCSV:
        CSVs = {key:[] for key in collections.keys()}

    # if user wants plotting of B
    if 'B' in BF:
        for i, pair in enumerate(collections.items()):
            name, collection = pair

            # calculate B in mT, no reshape done yet, raw array
            B_field_raw = array([collection.getB(pos) for pos in POS_raw])

            # rounding
            if rounding != None:
                B_field_raw = round(B_field_raw, rounding)

            # reshaping and splitting needed for matplotlib.pyplot.streamplot and plot_surface
            B_field = B_field_raw.reshape(lenys, lenzs, 3)
            Bx = B_field[:, :, 0]
            By = B_field[:, :, 1]
            Bz = B_field[:, :, 2]

            # if user wants stream plotting
            if 'stream' in modes:
                # creation of figure to host the plot
                fig_B_stream = figure(num=f'''B x = {x} stream; {name}''')
                ax_B_stream = fig_B_stream.add_subplot(aspect=1, title=f'''B direction, x = {x}; {name}''')

                ax_B_stream.streamplot(POSy, POSz, By, Bz, density=3)
                ax_B_stream.set_xlabel('y [mm]')
                ax_B_stream.set_ylabel('z [mm]')

            # if user wants quiver plotting
            if 'quiver' in modes:
                # creation of figure to host the plot
                fig_B_quiver = figure(num=f'''B x = {x} quiver; {name}''')
                ax_B_quiver = fig_B_quiver.add_subplot(aspect=1, title=f'''B direction, x = {x}; {name}''')

                # normalization of arrow size for better reading of direction
                ByBz_norm = array(list(map(normalize, B_field_raw[:, [1, 2]])))
                By_norm, Bz_norm = ByBz_norm[:, 0], ByBz_norm[:, 1]

                # splitting after normalization
                POSy_raw, POSz_raw = POS_raw[:, 1], POS_raw[:, 2]

                ax_B_quiver.quiver(POSy_raw, POSz_raw, By_norm, Bz_norm, units='xy')
                ax_B_quiver.set_xlabel('y [mm]')
                ax_B_quiver.set_ylabel('z [mm]')

            # if user wants surface plotting
            if 'surface' in modes:
                # creation of figure to host the plots
                fig_B_surface = figure(num=f'''B, x = {x} surface; {name}''')

                # creation of subplots
                ax_B_surf_x = fig_B_surface.add_subplot(131, title=f'''Bx, x = {x}; {name}''', projection='3d')
                ax_B_surf_y = fig_B_surface.add_subplot(132, title=f'''By, x = {x}; {name}''', projection='3d')
                ax_B_surf_z = fig_B_surface.add_subplot(133, title=f'''Bz, x = {x}; {name}''', projection='3d')

                # plotting Bx in given plane
                ax_B_surf_x.plot_surface(POSy, POSz, Bx)
                ax_B_surf_x.set_xlabel('y [mm]')
                ax_B_surf_x.set_ylabel('z [mm]')
                ax_B_surf_x.set_zlabel('Bx [mT]')

                # plotting By in given plane
                ax_B_surf_y.plot_surface(POSy, POSz, By)
                ax_B_surf_y.set_xlabel('y [mm]')
                ax_B_surf_y.set_ylabel('z [mm]')
                ax_B_surf_y.set_zlabel('By [mT]')

                # plotting Bz in given plane
                ax_B_surf_z.plot_surface(POSy, POSz, Bz)
                ax_B_surf_z.set_xlabel('y [mm]')
                ax_B_surf_z.set_ylabel('z [mm]')
                ax_B_surf_z.set_zlabel('Bz [mT]')

            # adding data to CSV
            if saveCSV:
                B_titles = array([[f'Bx {name}', f'By {name}', f'Bz {name}'],
                                  ['[mT]', '[mT]', '[mT]']])
                B_titled = vstack((B_titles, B_field_raw))
                CSVs[name].append(B_titled)

    # if user wants plotting of F
    if 'F' in BF:
        for i, pair in enumerate(collections.items()):
            name, collection = pair

            # calculate F in N, no reshape done yet, raw array
            F_field_raw = array([getF(pos, collection, sample) for pos in POS_raw])

            # rounding
            if rounding != None:
                F_field_raw = round(F_field_raw, rounding)

            # reshaping and splitting needed for matplotlib.pyplot.streamplot and plot_surface
            F_field = F_field_raw.reshape(lenys, lenzs, 3)
            Fx = F_field[:, :, 0]
            Fy = F_field[:, :, 1]
            Fz = F_field[:, :, 2]

            # if user wants stream plotting
            if 'stream' in modes:
                # creation of figure to host the plot
                fig_F_stream = figure(num=f'''F x = {x} stream; {name}''')
                ax_F_stream = fig_F_stream.add_subplot(aspect=1, title=f'''F direction, x = {x}; {name}''')

                ax_F_stream.streamplot(POSy, POSz, Fy, Fz, density=3)
                ax_F_stream.set_xlabel('y [mm]')
                ax_F_stream.set_ylabel('z [mm]')

            # if user wants quiver plotting
            if 'quiver' in modes:
                # creation of figure to host the plot
                fig_F_quiver = figure(num=f'''F x = {x} quiver; {name}''')
                ax_F_quiver = fig_F_quiver.add_subplot(aspect=1, title=f'''F direction, x = {x}; {name}''')

                # normalization of arrow size for better reading of direction
                FyFz_norm = array(list(map(normalize, F_field_raw[:, [1, 2]])))
                Fy_norm, Fz_norm = FyFz_norm[:, 0], FyFz_norm[:, 1]

                # splitting after normalization
                POSy_raw, POSz_raw = POS_raw[:, 1], POS_raw[:, 2]

                ax_F_quiver.quiver(POSy_raw, POSz_raw, Fy_norm, Fz_norm, units='xy')
                ax_F_quiver.set_xlabel('y [mm]')
                ax_F_quiver.set_ylabel('z [mm]')

            # if user wants surface plotting
            if 'surface' in modes:
                # creation of figure to host the plots
                fig_F_surface = figure(num=f'''F, x = {x} surface; {name}''')

                # creation of subplots
                ax_F_surf_x = fig_F_surface.add_subplot(131, title=f'''Fx, x = {x}; {name}''', projection='3d')
                ax_F_surf_y = fig_F_surface.add_subplot(132, title=f'''Fy, x = {x}; {name}''', projection='3d')
                ax_F_surf_z = fig_F_surface.add_subplot(133, title=f'''Fz, x = {x}; {name}''', projection='3d')

                # plotting Fx in given plane
                ax_F_surf_x.plot_surface(POSy, POSz, Fx)
                ax_F_surf_x.set_xlabel('y [mm]')
                ax_F_surf_x.set_ylabel('z [mm]')
                ax_F_surf_x.set_zlabel('Fx [N]')

                # plotting Fy in given plane
                ax_F_surf_y.plot_surface(POSy, POSz, Fy)
                ax_F_surf_y.set_xlabel('y [mm]')
                ax_F_surf_y.set_ylabel('z [mm]')
                ax_F_surf_y.set_zlabel('Fy [N]')

                # plotting Fz in given plane
                ax_F_surf_z.plot_surface(POSy, POSz, Fz)
                ax_F_surf_z.set_xlabel('y [mm]')
                ax_F_surf_z.set_ylabel('z [mm]')
                ax_F_surf_z.set_zlabel('Fz [N]')

            # adding data to CSV
            if saveCSV:
                F_titles = array([[f'Fx {name}', f'Fy {name}', f'Fz {name}'],
                                  ['[N]', '[N]', '[N]']])
                F_titled = vstack((F_titles, F_field_raw))
                CSVs[name].append(F_titled)

    # if user wants to save data in CSV
    if saveCSV:
        dirname = "CSV_output"
        try:
            # Create target Directory
            mkdir(dirname)
            print(f"Directory {dirname} created, saving CSV file there")
        except FileExistsError:
            print(f"Directory {dirname} already exists, saving CSV file there")

        # prepare CSV data with POS
        POS_titles = array([['x', 'y', 'z'],
                            ['[mm]', '[mm]', '[mm]']])
        POS_titled = vstack((POS_titles, POS_raw))
        CSV_data = [POS_titled]

        # append other data
        for arr in list(CSVs.values()):
            CSV_data.append(hstack(arr))

        # save it
        header = f'Simulation 2D plane x | {datetime.now()}'
        savetxt(f'CSV_output/{BF}_2D_plane_x.csv', hstack(CSV_data), delimiter=';', fmt='%s', header=header)

    if showim:
        show()


def plot_2D_plane_y(xs=array([]), y=0, zs=array([]), collections={}, sample={}, modes=['stream'], BF='BF', rounding=10, saveCSV=False, showim=False):
    """
    -----------
    DESCRIPTION
    -----------

    Plots B and F generated by a collection of magnets into a ferromagnetic sample.
    Those variables are plotted on a given y plane

    ----------
    PARAMETERS
    ----------

    :param xs: numpy.array | contains the x interval values where the variables are evaluated [mm]
    :param y: float | float for y plane [mm]
    :param zs: numpy.array | contains the z interval values where the variables are evaluated [mm]
    :param collections: dict | the magnets setup to be studied arranged like {'name':magpylib.Collection}
    :param sample: dict | keys 'demagnetizing_factor' [], 'volume' [m3] and 'M_saturation' [A/m]
    :param modes: list | may contain 'stream', 'quiver' or 'surface' according to plotting fashion
    :param BF: str | 'B' to plot Bx, By, Bz; 'F' to plot Fx, Fy, Fz; 'BF' for all
    :param rounding: int | decimal places to be left after rounding of final values. 'None' for no rouding.
    :param saveCSV: bool | True for saving a CSV file with the data generated by the function
    :param showim: bool | True to show images after calculation, False to call yourself show() afterwards in the code
    :return: plots matplotlib graphs. show() needs to be called manually

    -------
    EXAMPLE
    -------

    # imports
        >>> from numpy import linspace, pi
        >>> from matplotlib.pyplot import show
        >>> from magpylib import Collection, displaySystem
        >>> from magpylib.source.magnet import Cylinder
        >>> from magforce import plot_2D_plane_y

    # sample Definition
        >>> demagnetizing_factor = 1/3             # sphere
        >>> volume = 4 / 3 * pi * (4 / 1000) ** 3  # V sphere r=4mm [m3]
        >>> M_saturation = 1.400e6                 # Ms Co room temperature [A/m]
        >>> sample = {'demagnetizing_factor': demagnetizing_factor, 'volume': volume, 'M_saturation': M_saturation}

    # magnet collection definition
        >>> m1 = Cylinder(mag=[0, 0, 1300],
        ...               dim=[10, 20],
        ...               pos=[0, 0, -20])  # center is at z = -20mm

        >>> m2 = Cylinder(mag=[0, 0, 1300],
        ...               dim=[10, 20],
        ...               pos=[0, 0, 20]) # center is at z = 20mm

        >>> both = Collection(m1, m2)

    # magnet collection visualisation
        >>> displaySystem(both, suppress=True)
        <Figure size 640x640 with 1 Axes>

    # study of different arrangements along z axis
        >>> plot_2D_plane_y(xs=linspace(-10, 10, 35),
        ...                 y=0,
        ...                 zs=linspace(-20, 20, 35),
        ...                 collections={'z-20': m1,
        ...                              'both': both},
        ...                 sample=sample,
        ...                 modes=['stream', 'quiver', 'surface'],
        ...                 BF='BF',
        ...                 saveCSV=False,
        ...                 showim=True)
    """

    # get array length to reshape B or F array correctly
    lenxs = len(xs)
    lenzs = len(zs)

    # generate points for B and F calculation, no reshape done yet, raw array
    POS_raw = array([(x, y, z) for z in zs for x in xs])

    # reshaping and splitting needed for matplotlib.pyplot.streamplot and plot_surface
    POS = POS_raw.reshape(lenxs, lenzs, 3)
    POSx = POS[:, :, 0]
    POSz = POS[:, :, 2]

    # pass BF to uppercase to avoid BF='bf' not returning anything
    BF = BF.upper()

    # dictionary to store all the calculated values that will generate the CSV file afterwards
    if saveCSV:
        CSVs = {key:[] for key in collections.keys()}

    # if user wants plotting of B
    if 'B' in BF:
        for i, pair in enumerate(collections.items()):
            name, collection = pair

            # calculate B in mT, no reshape done yet, raw array
            B_field_raw = array([collection.getB(pos) for pos in POS_raw])

            # rounding
            if rounding != None:
                B_field_raw = round(B_field_raw, rounding)

            # reshaping and splitting needed for matplotlib.pyplot.streamplot and plot_surface
            B_field = B_field_raw.reshape(lenxs, lenzs, 3)
            Bx = B_field[:, :, 0]
            By = B_field[:, :, 1]
            Bz = B_field[:, :, 2]

            # if user wants stream plotting
            if 'stream' in modes:
                # creation of figure to host the plot
                fig_B_stream = figure(num=f'''B y = {y} stream; {name}''')
                ax_B_stream = fig_B_stream.add_subplot(aspect=1, title=f'''B direction, y = {y}; {name}''')

                ax_B_stream.streamplot(POSx, POSz, Bx, Bz, density=3)
                ax_B_stream.set_xlabel('x [mm]')
                ax_B_stream.set_ylabel('z [mm]')

            # if user wants quiver plotting
            if 'quiver' in modes:
                # creation of figure to host the plot
                fig_B_quiver = figure(num=f'''B y = {y} quiver; {name}''')
                ax_B_quiver = fig_B_quiver.add_subplot(aspect=1, title=f'''B direction, y = {y}; {name}''')

                # normalization of arrow size for better reading of direction
                BxBz_norm = array(list(map(normalize, B_field_raw[:, [0, 2]])))
                Bx_norm, Bz_norm = BxBz_norm[:, 0], BxBz_norm[:, 1]

                # splitting after normalization
                POSx_raw, POSz_raw = POS_raw[:, 0], POS_raw[:, 2]

                ax_B_quiver.quiver(POSx_raw, POSz_raw, Bx_norm, Bz_norm, units='xy')
                ax_B_quiver.set_xlabel('x [mm]')
                ax_B_quiver.set_ylabel('z [mm]')

            # if user wants surface plotting
            if 'surface' in modes:
                # creation of figure to host the plots
                fig_B_surface = figure(num=f'''B, y = {y} surface; {name}''')

                # creation of subplots
                ax_B_surf_x = fig_B_surface.add_subplot(131, title=f'''Bx, y = {y}; {name}''', projection='3d')
                ax_B_surf_y = fig_B_surface.add_subplot(132, title=f'''By, y = {y}; {name}''', projection='3d')
                ax_B_surf_z = fig_B_surface.add_subplot(133, title=f'''Bz, y = {y}; {name}''', projection='3d')

                # plotting Bx in given plane
                ax_B_surf_x.plot_surface(POSx, POSz, Bx)
                ax_B_surf_x.set_xlabel('x [mm]')
                ax_B_surf_x.set_ylabel('z [mm]')
                ax_B_surf_x.set_zlabel('Bx [mT]')

                # plotting By in given plane
                ax_B_surf_y.plot_surface(POSx, POSz, By)
                ax_B_surf_y.set_xlabel('x [mm]')
                ax_B_surf_y.set_ylabel('z [mm]')
                ax_B_surf_y.set_zlabel('By [mT]')

                # plotting Bz in given plane
                ax_B_surf_z.plot_surface(POSx, POSz, Bz)
                ax_B_surf_z.set_xlabel('x [mm]')
                ax_B_surf_z.set_ylabel('z [mm]')
                ax_B_surf_z.set_zlabel('Bz [mT]')

            # adding data to CSV
            if saveCSV:
                B_titles = array([[f'Bx {name}', f'By {name}', f'Bz {name}'],
                                  ['[mT]', '[mT]', '[mT]']])
                B_titled = vstack((B_titles, B_field_raw))
                CSVs[name].append(B_titled)

    # if user wants plotting of F
    if 'F' in BF:
        for i, pair in enumerate(collections.items()):
            name, collection = pair

            # calculate F in N, no reshape done yet, raw array
            F_field_raw = array([getF(pos, collection, sample) for pos in POS_raw])

            # rounding
            if rounding != None:
                F_field_raw = round(F_field_raw, rounding)

            # reshaping and splitting needed for matplotlib.pyplot.streamplot and plot_surface
            F_field = F_field_raw.reshape(lenxs, lenzs, 3)
            Fx = F_field[:, :, 0]
            Fy = F_field[:, :, 1]
            Fz = F_field[:, :, 2]

            # if user wants stream plotting
            if 'stream' in modes:
                # creation of figure to host the plot
                fig_F_stream = figure(num=f'''F y = {y} stream; {name}''')
                ax_F_stream = fig_F_stream.add_subplot(aspect=1, title=f'''F direction, y = {y}; {name}''')

                ax_F_stream.streamplot(POSx, POSz, Fx, Fz, density=3)
                ax_F_stream.set_xlabel('x [mm]')
                ax_F_stream.set_ylabel('z [mm]')

            # if user wants quiver plotting
            if 'quiver' in modes:
                # creation of figure to host the plot
                fig_F_quiver = figure(num=f'''F y = {y} quiver; {name}''')
                ax_F_quiver = fig_F_quiver.add_subplot(aspect=1, title=f'''F direction, y = {y}; {name}''')

                # normalization of arrow size for better reading of direction
                FxFz_norm = array(list(map(normalize, F_field_raw[:, [0, 2]])))
                Fx_norm, Fz_norm = FxFz_norm[:, 0], FxFz_norm[:, 1]

                # splitting after normalization
                POSx_raw, POSz_raw = POS_raw[:, 0], POS_raw[:, 2]

                ax_F_quiver.quiver(POSx_raw, POSz_raw, Fx_norm, Fz_norm, units='xy')
                ax_F_quiver.set_xlabel('x [mm]')
                ax_F_quiver.set_ylabel('z [mm]')

            # if user wants surface plotting
            if 'surface' in modes:
                # creation of figure to host the plots
                fig_F_surface = figure(num=f'''F, y = {y} surface; {name}''')

                # creation of subplots
                ax_F_surf_x = fig_F_surface.add_subplot(131, title=f'''Fx, y = {y}; {name}''', projection='3d')
                ax_F_surf_y = fig_F_surface.add_subplot(132, title=f'''Fy, y = {y}; {name}''', projection='3d')
                ax_F_surf_z = fig_F_surface.add_subplot(133, title=f'''Fz, y = {y}; {name}''', projection='3d')

                # plotting Fx in given plane
                ax_F_surf_x.plot_surface(POSx, POSz, Fx)
                ax_F_surf_x.set_xlabel('x [mm]')
                ax_F_surf_x.set_ylabel('z [mm]')
                ax_F_surf_x.set_zlabel('Fx [N]')

                # plotting Fy in given plane
                ax_F_surf_y.plot_surface(POSx, POSz, Fy)
                ax_F_surf_y.set_xlabel('x [mm]')
                ax_F_surf_y.set_ylabel('z [mm]')
                ax_F_surf_y.set_zlabel('Fy [N]')

                # plotting Fz in given plane
                ax_F_surf_z.plot_surface(POSx, POSz, Fz)
                ax_F_surf_z.set_xlabel('x [mm]')
                ax_F_surf_z.set_ylabel('z [mm]')
                ax_F_surf_z.set_zlabel('Fz [N]')

            # adding data to CSV
            if saveCSV:
                F_titles = array([[f'Fx {name}', f'Fy {name}', f'Fz {name}'],
                                  ['[N]', '[N]', '[N]']])
                F_titled = vstack((F_titles, F_field_raw))
                CSVs[name].append(F_titled)

    # if user wants to save data in CSV
    if saveCSV:
        dirname = "CSV_output"
        try:
            # Create target Directory
            mkdir(dirname)
            print(f"Directory {dirname} created, saving CSV file there")
        except FileExistsError:
            print(f"Directory {dirname} already exists, saving CSV file there")

        # prepare CSV data with POS
        POS_titles = array([['x', 'y', 'z'],
                            ['[mm]', '[mm]', '[mm]']])
        POS_titled = vstack((POS_titles, POS_raw))
        CSV_data = [POS_titled]

        # append other data
        for arr in list(CSVs.values()):
            CSV_data.append(hstack(arr))

        # save it
        header = f'Simulation 2D plane y | {datetime.now()}'
        savetxt(f'CSV_output/{BF}_2D_plane_y.csv', hstack(CSV_data), delimiter=';', fmt='%s', header=header)

    if showim:
        show()


def plot_2D_plane_z(xs=array([]), ys=array([]), z=0, collections={}, sample={}, modes=['stream'], BF='BF', rounding=10, saveCSV=False, showim=False):
    """
    -----------
    DESCRIPTION
    -----------

    Plots B and F generated by a collection of magnets into a ferromagnetic sample.
    Those variables are plotted on a given z plane

    ----------
    PARAMETERS
    ----------

    :param xs: numpy.array | contains the x interval values where the variables are evaluated [mm]
    :param ys: numpy.array | contains the y interval values where the variables are evaluated [mm]
    :param z: float | float for z plane [mm]
    :param collections: dict | the magnets setup to be studied arranged like {'name':magpylib.Collection}
    :param sample: dict | keys 'demagnetizing_factor' [], 'volume' [m3] and 'M_saturation' [A/m]
    :param modes: list | may contain 'stream', 'quiver' or 'surface' according to plotting fashion
    :param BF: str | 'B' to plot Bx, By, Bz; 'F' to plot Fx, Fy, Fz; 'BF' for all
    :param rounding: int | decimal places to be left after rounding of final values. 'None' for no rouding.
    :param saveCSV: bool | True for saving a CSV file with the data generated by the function
    :param showim: bool | True to show images after calculation, False to call yourself show() afterwards in the code
    :return: plots matplotlib graphs. show() needs to be called manually

    -------
    EXAMPLE
    -------

    # imports
        >>> from numpy import linspace, pi
        >>> from matplotlib.pyplot import show
        >>> from magpylib import Collection, displaySystem
        >>> from magpylib.source.magnet import Cylinder
        >>> from magforce import plot_2D_plane_z

    # sample Definition
        >>> demagnetizing_factor = 1/3             # sphere
        >>> volume = 4 / 3 * pi * (4 / 1000) ** 3  # V sphere r=4mm [m3]
        >>> M_saturation = 1.400e6                 # Ms Co room temperature [A/m]
        >>> sample = {'demagnetizing_factor': demagnetizing_factor, 'volume': volume, 'M_saturation': M_saturation}

    # magnet collection definition
        >>> m1 = Cylinder(mag=[0, 0, 1300],
        ...               dim=[10, 20],
        ...               pos=[0, 0, -20])  # center is at z = -20mm

        >>> m2 = Cylinder(mag=[0, 0, 1300],
        ...               dim=[10, 20],
        ...               pos=[0, 0, 20]) # center is at z = 20mm

        >>> both = Collection(m1, m2)

    # magnet collection visualisation
        >>> displaySystem(both, suppress=True)
        <Figure size 640x640 with 1 Axes>

    # study of different arrangements along z axis
        >>> plot_2D_plane_z(xs=linspace(-10, 10, 35),
        ...                 ys=linspace(-10, 10, 35),
        ...                 z=0,
        ...                 collections={'z-20': m1,
        ...                              'both': both},
        ...                 sample=sample,
        ...                 modes=['stream', 'quiver', 'surface'],
        ...                 BF='BF',
        ...                 saveCSV=False,
        ...                 showim=True)
    """

    # get array length to reshape B or F array correctly
    lenxs = len(xs)
    lenys = len(ys)

    # generate points for B and F calculation, no reshape done yet, raw array
    POS_raw = array([(x, y, z) for y in ys for x in xs])

    # reshaping and splitting needed for matplotlib.pyplot.streamplot and plot_surface
    POS = POS_raw.reshape(lenxs, lenys, 3)
    POSx = POS[:, :, 0]
    POSy = POS[:, :, 1]

    # pass BF to uppercase to avoid BF='bf' not returning anything
    BF = BF.upper()

    # dictionary to store all the calculated values that will generate the CSV file afterwards
    if saveCSV:
        CSVs = {key:[] for key in collections.keys()}

    # if user wants plotting of B
    if 'B' in BF:
        for i, pair in enumerate(collections.items()):
            name, collection = pair

            # calculate B in mT, no reshape done yet, raw array
            B_field_raw = array([collection.getB(pos) for pos in POS_raw])

            # rounding
            if rounding != None:
                B_field_raw = round(B_field_raw, rounding)

            # reshaping and splitting needed for matplotlib.pyplot.streamplot and plot_surface
            B_field = B_field_raw.reshape(lenxs, lenys, 3)
            Bx = B_field[:, :, 0]
            By = B_field[:, :, 1]
            Bz = B_field[:, :, 2]

            # if user wants stream plotting
            if 'stream' in modes:
                # creation of figure to host the plot
                fig_B_stream = figure(num=f'''B z = {z} stream; {name}''')
                ax_B_stream = fig_B_stream.add_subplot(aspect=1, title=f'''B direction, z = {z}; {name}''')

                ax_B_stream.streamplot(POSx, POSy, Bx, By, density=3)
                ax_B_stream.set_xlabel('x [mm]')
                ax_B_stream.set_ylabel('y [mm]')

            # if user wants quiver plotting
            if 'quiver' in modes:
                # creation of figure to host the plot
                fig_B_quiver = figure(num=f'''B z = {z} quiver; {name}''')
                ax_B_quiver = fig_B_quiver.add_subplot(aspect=1, title=f'''B direction, z = {z}; {name}''')

                # normalization of arrow size for better reading of direction
                BxBy_norm = array(list(map(normalize, B_field_raw[:, [0, 1]])))
                Bx_norm, By_norm = BxBy_norm[:, 0], BxBy_norm[:, 1]

                # splitting after normalization
                POSx_raw, POSy_raw = POS_raw[:, 0], POS_raw[:, 1]

                ax_B_quiver.quiver(POSx_raw, POSy_raw, Bx_norm, By_norm, units='xy')
                ax_B_quiver.set_xlabel('x [mm]')
                ax_B_quiver.set_ylabel('y [mm]')

            # if user wants surface plotting
            if 'surface' in modes:
                # creation of figure to host the plots
                fig_B_surface = figure(num=f'''B, z = {z} surface; {name}''')

                # creation of subplots
                ax_B_surf_x = fig_B_surface.add_subplot(131, title=f'''Bx, z = {z}; {name}''', projection='3d')
                ax_B_surf_y = fig_B_surface.add_subplot(132, title=f'''By, z = {z}; {name}''', projection='3d')
                ax_B_surf_z = fig_B_surface.add_subplot(133, title=f'''Bz, z = {z}; {name}''', projection='3d')

                # plotting Bx in given plane
                ax_B_surf_x.plot_surface(POSx, POSy, Bx)
                ax_B_surf_x.set_xlabel('x [mm]')
                ax_B_surf_x.set_ylabel('y [mm]')
                ax_B_surf_x.set_zlabel('Bx [mT]')

                # plotting By in given plane
                ax_B_surf_y.plot_surface(POSx, POSy, By)
                ax_B_surf_y.set_xlabel('x [mm]')
                ax_B_surf_y.set_ylabel('y [mm]')
                ax_B_surf_y.set_zlabel('By [mT]')

                # plotting Bz in given plane
                ax_B_surf_z.plot_surface(POSx, POSy, Bz)
                ax_B_surf_z.set_xlabel('x [mm]')
                ax_B_surf_z.set_ylabel('y [mm]')
                ax_B_surf_z.set_zlabel('Bz [mT]')

            # adding data to CSV
            if saveCSV:
                B_titles = array([[f'Bx {name}', f'By {name}', f'Bz {name}'],
                                  ['[mT]', '[mT]', '[mT]']])
                B_titled = vstack((B_titles, B_field_raw))
                CSVs[name].append(B_titled)

    # if user wants plotting of F
    if 'F' in BF:
        for i, pair in enumerate(collections.items()):
            name, collection = pair

            # calculate F in N, no reshape done yet, raw array
            F_field_raw = array([getF(pos, collection, sample) for pos in POS_raw])

            # rounding
            if rounding != None:
                F_field_raw = round(F_field_raw, rounding)

            # reshaping and splitting needed for matplotlib.pyplot.streamplot and plot_surface
            F_field = F_field_raw.reshape(lenxs, lenys, 3)
            Fx = F_field[:, :, 0]
            Fy = F_field[:, :, 1]
            Fz = F_field[:, :, 2]

            # if user wants stream plotting
            if 'stream' in modes:
                # creation of figure to host the plot
                fig_F_stream = figure(num=f'''F z = {z} stream; {name}''')
                ax_F_stream = fig_F_stream.add_subplot(aspect=1, title=f'''F direction, z = {z}; {name}''')

                ax_F_stream.streamplot(POSx, POSy, Fx, Fy, density=3)
                ax_F_stream.set_xlabel('x [mm]')
                ax_F_stream.set_ylabel('y [mm]')

            # if user wants quiver plotting
            if 'quiver' in modes:
                # creation of figure to host the plot
                fig_F_quiver = figure(num=f'''F z = {z} quiver; {name}''')
                ax_F_quiver = fig_F_quiver.add_subplot(aspect=1, title=f'''F direction, z = {z}; {name}''')

                # normalization of arrow size for better reading of direction
                FxFy_norm = array(list(map(normalize, F_field_raw[:, [0, 1]])))
                Fx_norm, Fy_norm = FxFy_norm[:, 0], FxFy_norm[:, 1]

                # splitting after normalization
                POSx_raw, POSy_raw = POS_raw[:, 0], POS_raw[:, 1]

                ax_F_quiver.quiver(POSx_raw, POSy_raw, Fx_norm, Fy_norm, units='xy')
                ax_F_quiver.set_xlabel('x [mm]')
                ax_F_quiver.set_ylabel('y [mm]')

            # if user wants surface plotting
            if 'surface' in modes:
                # creation of figure to host the plots
                fig_F_surface = figure(num=f'''F, z = {z} surface; {name}''')

                # creation of subplots
                ax_F_surf_x = fig_F_surface.add_subplot(131, title=f'''Fx, z = {z}; {name}''', projection='3d')
                ax_F_surf_y = fig_F_surface.add_subplot(132, title=f'''Fy, z = {z}; {name}''', projection='3d')
                ax_F_surf_z = fig_F_surface.add_subplot(133, title=f'''Fz, z = {z}; {name}''', projection='3d')

                # plotting Fx in given plane
                ax_F_surf_x.plot_surface(POSx, POSy, Fx)
                ax_F_surf_x.set_xlabel('x [mm]')
                ax_F_surf_x.set_ylabel('y [mm]')
                ax_F_surf_x.set_zlabel('Fx [N]')

                # plotting Fy in given plane
                ax_F_surf_y.plot_surface(POSx, POSy, Fy)
                ax_F_surf_y.set_xlabel('x [mm]')
                ax_F_surf_y.set_ylabel('y [mm]')
                ax_F_surf_y.set_zlabel('Fy [N]')

                # plotting Fz in given plane
                ax_F_surf_z.plot_surface(POSx, POSy, Fz)
                ax_F_surf_z.set_xlabel('x [mm]')
                ax_F_surf_z.set_ylabel('y [mm]')
                ax_F_surf_z.set_zlabel('Fz [N]')

            # adding data to CSV
            if saveCSV:
                F_titles = array([[f'Fx {name}', f'Fy {name}', f'Fz {name}'],
                                  ['[N]', '[N]', '[N]']])
                F_titled = vstack((F_titles, F_field_raw))
                CSVs[name].append(F_titled)

    # if user wants to save data in CSV
    if saveCSV:
        dirname = "CSV_output"
        try:
            # Create target Directory
            mkdir(dirname)
            print(f"Directory {dirname} created, saving CSV file there")
        except FileExistsError:
            print(f"Directory {dirname} already exists, saving CSV file there")

        # prepare CSV data with POS
        POS_titles = array([['x', 'y', 'z'],
                            ['[mm]', '[mm]', '[mm]']])
        POS_titled = vstack((POS_titles, POS_raw))
        CSV_data = [POS_titled]

        # append other data
        for arr in list(CSVs.values()):
            CSV_data.append(hstack(arr))

        # save it
        header = f'Simulation 2D plane z | {datetime.now()}'
        savetxt(f'CSV_output/{BF}_2D_plane_z.csv', hstack(CSV_data), delimiter=';', fmt='%s', header=header)

    if showim:
        show()


# functions for plotting 3D

def plot_3D(xs=array([]), ys=array([]), zs=array([]), collections={}, sample={}, BF='BF', saveCSV=False, showim=False):
    """
    -----------
    DESCRIPTION
    -----------

    Plots B and F on 3D

    ----------
    PARAMETERS
    ----------

    :param xs: numpy.array()
    :param ys: numpy.array()
    :param zs: numpy.array()
    :param collections: dict | the magnets setup to be studied arranged like {'name':magpylib.Collection}
    :param sample: dict | keys 'demagnetizing_factor' [], 'volume' [m3] and 'M_saturation' [A/m]
    :param BF: str | 'B' to plot Bx, By, Bz; 'F' to plot Fx, Fy, Fz; 'BF' for all
    :param saveCSV: bool | True for saving a CSV file with the data generated by the function
    :param showim: bool | True to show images after calculation, False to call yourself show() afterwards in the code
    :return: plots matplotlib graphs. show() needs to be called manually

    -------
    EXAMPLE
    -------

    # imports
        >>> from numpy import linspace, pi
        >>> from matplotlib.pyplot import show
        >>> from magpylib import Collection, displaySystem
        >>> from magpylib.source.magnet import Cylinder
        >>> from magforce import plot_3D

    # sample Definition
        >>> demagnetizing_factor = 1/3             # sphere
        >>> volume = 4 / 3 * pi * (4 / 1000) ** 3  # V sphere r=4mm [m3]
        >>> M_saturation = 1.400e6                 # Ms Co room temperature [A/m]
        >>> sample = {'demagnetizing_factor': demagnetizing_factor, 'volume': volume, 'M_saturation': M_saturation}

    # magnet collection definition
        >>> m1 = Cylinder(mag=[0, 0, 1300],
        ...               dim=[10, 20],
        ...               pos=[0, 0, -20])  # center is at z = -20mm

        >>> m2 = Cylinder(mag=[0, 0, 1300],
        ...               dim=[10, 20],
        ...               pos=[0, 0, 20]) # center is at z = 20mm

        >>> both = Collection(m1, m2)

    # magnet collection visualisation
        >>> displaySystem(both, suppress=True)
        <Figure size 640x640 with 1 Axes>

    # study of different arrangements along z axis
        >>> plot_3D(xs=linspace(-10, 10, 9),
        ...         ys=linspace(-10, 10, 9),
        ...         zs=linspace(-20, 20, 9),
        ...         collections={'z-20': m1,
        ...                      'both': both},
        ...         sample=sample,
        ...         BF='BF',
        ...         saveCSV=False,
        ...         showim=True)
    """

    # get array length to reshape B or F array correctly
    lenx = len(xs)
    leny = len(ys)
    lenz = len(zs)

    # pass BF to uppercase to avoid BF='bf' not returning anything
    BF = BF.upper()

    # dictionary to store all the calculated values that will generate the CSV file afterwards
    if saveCSV:
        CSVs = {key:[] for key in collections.keys()}

    # generate points for B and F calculation, no reshape done yet, raw array
    POS_raw = array([(x, y, z) for x in xs for y in ys for z in zs])

    # reshaping and splitting needed for matplotlib 3D
    POS = POS_raw.reshape(lenx, leny, lenz, 3)
    POSx = POS[:, :, :, 0]
    POSy = POS[:, :, :, 1]
    POSz = POS[:, :, :, 2]

    # arrow size
    arrow_size = 2

    if 'B' in BF:
        for i, pair in enumerate(collections.items()):
            name, collection = pair

            # calculate B in mT, no reshape done yet, raw array
            B_field_raw = array([collection.getB(pos) for pos in POS_raw])

            # reshaping and splitting needed for matplotlib 3D
            B_field = B_field_raw.reshape(lenx, leny, lenz, 3)
            Bx = B_field[:, :, :, 0]
            By = B_field[:, :, :, 1]
            Bz = B_field[:, :, :, 2]

            # plotting
            fig3d_B = figure(num=f'''B 3D; {name}''')
            ax_B = fig3d_B.add_subplot(title=f'B 3D; {name}',projection='3d')
            ax_B.quiver(POSx, POSy, POSz, Bx, By, Bz, normalize=True, length=arrow_size)

            # adding data to CSV
            if saveCSV:
                B_titles = array([[f'Bx {name}', f'By {name}', f'Bz {name}'],
                                  ['[mT]', '[mT]', '[mT]']])
                B_titled = vstack((B_titles, B_field_raw))
                CSVs[name].append(B_titled)

    if 'F' in BF:
        for i, pair in enumerate(collections.items()):
            name, collection = pair

            # calculate F in N, no reshape done yet, raw array
            F_field_raw = array([getF(pos, collection, sample) for pos in POS_raw])

            # reshaping and splitting needed for matplotlib 3D
            F_field = F_field_raw.reshape(lenx, leny, lenz, 3)
            Fx = F_field[:, :, :, 0]
            Fy = F_field[:, :, :, 1]
            Fz = F_field[:, :, :, 2]

            # plotting
            fig3d_F = figure(num=f'''F 3D; {name}''')
            ax_F = fig3d_F.add_subplot(title=f'F 3D; {name}',projection='3d')
            ax_F.quiver(POSx, POSy, POSz, Fx, Fy, Fz, normalize=True, length=arrow_size)

            # adding data to CSV
            if saveCSV:
                F_titles = array([[f'Fx {name}', f'Fy {name}', f'Fz {name}'],
                                  ['[N]', '[N]', '[N]']])
                F_titled = vstack((F_titles, F_field_raw))
                CSVs[name].append(F_titled)

    # if user wants to save data in CSV
    if saveCSV:
        dirname = "CSV_output"
        try:
            # Create target Directory
            mkdir(dirname)
            print(f"Directory {dirname} created, saving CSV file there")
        except FileExistsError:
            print(f"Directory {dirname} already exists, saving CSV file there")

        # prepare CSV data with POS
        POS_titles = array([['x', 'y', 'z'],
                            ['[mm]', '[mm]', '[mm]']])
        POS_titled = vstack((POS_titles, POS_raw))
        CSV_data = [POS_titled]

        # append other data
        for arr in list(CSVs.values()):
            CSV_data.append(hstack(arr))

        # save it
        header = f'Simulation 3D | {datetime.now()}'
        savetxt(f'CSV_output/{BF}_3D.csv', hstack(CSV_data), delimiter=';', fmt='%s', header=header)

    if showim:
        show()
